Server: would store the code that detemines the most efficient way
to request any of that data from the database

Authentication: determines that the user at that is trying to access the server or
the database is who they say they are


********
collection: it's like a group of object except those object
are the second type of data called documents
you can almost see them as an array of things and each 
of those things can also have properties that point to others
collections


documents:
doc.data() in order to get the data of the snapshot


collectionRef.onSnapshot(): whenever the collection ref updates or 
whenever this code gets run for the first time
this collection ref will send us the snapshot representing the code of our collections objects array at the time
when this code renders

********
React Firebase rules:
when ever we make this update we always to return a new array even if the object stays the same

Utility functions: allow us to keep our files clean and organize functions that we may need in multiple files in one location


Data Normalization: is the ideal way that we should be storing large arrays of elements
where we need the individual element inside of our reducer

Definition: ---> you can store lists of elements as objects instead of arrays
this is actually a pretty common thing that will encounter when talking about back ends and databases
(hash table)


styled-component: really help us make sure that we keep all our components and what the component is concerned
about in one place in our javascript

Data Flow:


High Order Component: It's just a function that takes a component and then returns a new component
that has additional functionality on it that renders out our original component that we
gave to it



******Observables + Observer Pattern:
The observable is capable of stopping the stream at some point.

The observable just knows that there's going to be different listeners listening
to it once it subscribes.

The moment it subscribes the observer what gets a reference to this 
subscription and it will just call the next whenever it gets a new value call,
the error or whatever gets an error and code complete whenever a complete
if at any point a cup piece of code tells the observervable hey i want to 
unsubscribe from you. => The observer just takes that reference and throws it out
and it's like oh I don't need the subscription => I'm just going to continue
emitting my events and firing these functions calls on all of the other observers
that are still listening to me





Whenever i get a new value inside of my stream 
I'm just gonna give that to the next function

The complete call rarely happens inside a firebase because firebase is a live
database which means that updates can always happen


******
Call is the effect inside of our generator function that invokes the method, we can 
technically write this the exact same way
All the call syntax is it's a method that takes as its first argument some function or 
method and then the subsequent arguments will be the parameters that you passed into 
this function


*****
Put is the saga effect for creating action and it's exactly dispatch



*******take() --- takeEvery() --- takeLatest()
take() is following just the basic generator function that we learned about a few lessions ago

takeEvery() kicks off a new task using the generator that we passed to it as its second argument
for every increment action that come in
==>> non-blocking
==>> takeEvery is creating new sub tasks. It's spawning new sagas for every increment action
to come in which means that 3 increment actions are running on three new on increment sagas.


takeLatest() cancel every previous spawn saga that was generated except for the latest one

takeLatest and takeEvery being what allows this saga that's actually catch this fetch collection
start action that the saga passes to all of our sagas and then depending on what the success
or failure of the actuall fetch call from the firestore was we put out new fetch collection
success or fetch collection failure actions so "put" essentially the saga way of dispatching
new actions

*****all()
all(): takes an array of sagas
